<!--
ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§
ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§
ðŸŸ§ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§ðŸŸ§
ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ¥â¬›ðŸŸ§ðŸŸ§ðŸŸ§
ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§

â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬›
â¬›â¬›ðŸŸ¥ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ¥â¬›â¬›
â¬›ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥â¬›
ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨â¬œâ¬œðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨â¬œâ¬œâ¬œâ¬œðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨â¬œâ¬œâ¬œâ¬œðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨â¬œâ¬œðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥
â¬›ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥â¬›
â¬›â¬›ðŸŸ¥ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ¥â¬›â¬›
â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬›

ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸªðŸŸ«â¬›â¬œ
â¹ï¸âŽâœ³ï¸âœ´ï¸â‡ï¸ðŸ…¿ï¸ðŸ†™
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>EmojiPaint</title>
    <style>

        /* region Reset */
        /* @see https://www.joshwcomeau.com/css/custom-css-reset */

        *, *::before, *::after {
            box-sizing: border-box;
        }

        input, button, textarea, select {
            font: inherit;
            color: inherit;
        }

        /* endregion */

        /* region Standard HTML tags */

        body {
            margin: 0;
            padding: 1rem;
            color: #333;
            font-family: "Consolas", monospace;
        }

        /* endregion */

        /* region EmojiPaint */

        .emoji-paint__metrics {
            position: absolute;
            /* TODO: same style as canvas element */
        }

        .emoji-paint__container {
            --canvas-background: #FFF;
            --selection-color: #FFFFE0;
            --label-emoji-text-shadow: 1px 1px 0 #0006;

            border: 1px outset;
            border-radius: 4px;
            background: #CCC;
        }

        .emoji-paint__head {
            padding: 0.5rem 1rem;
            border-bottom: 1px outset;
            border-radius: 3px 3px 0 0;
            background: #AAA;
            font-weight: bold;
        }

        .emoji-paint__head:first-letter {
            text-shadow: var(--label-emoji-text-shadow);
        }

        .emoji-paint__body {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
        }

        .emoji-paint__icon-btn {
            padding: 1px;
            line-height: 1.1875rem;
            text-shadow: var(--label-emoji-text-shadow);
            vertical-align: top;
        }

        .emoji-paint__toolbar-top {
            display: flex;
        }

        .emoji-paint__toolbar-separator {
            flex: 0 1 0;
            margin-block: 0.25rem;
            margin-inline: 0.5rem;
        }

        .emoji-paint__toolbar-spacer {
            flex: 1 1 auto;
        }

        .emoji-paint__toolbar-top-new input[type='number'] {
            width: 6ch;
            text-align: right;
        }

        .emoji-paint__toolbar-label {
            margin-inline-end: 0.5rem;
        }

        .emoji-paint__canvas {
            cursor: crosshair;
            user-select: none;
            padding: 0.25rem;
            border: 1px inset;
            overflow: auto;
            background: var(--canvas-background);
            white-space: pre;
        }

        .emoji-paint__canvas,
        .emoji-paint__metrics {
            font-size: 1rem;
        }

        .emoji-paint__palette {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .emoji-paint__palette-item {
            margin: 0;
            border-radius: 0.25rem;
            padding: 0.175rem;
            appearance: none;
            transition: background-color 250ms ease-out;
        }

        .emoji-paint__palette-item::before {
            content: attr(value);
        }

        .emoji-paint__palette-item:checked {
            background-color: var(--selection-color);
        }

        .emoji-paint__palette_dropdown {
            flex: 0 1 0;
            align-self: stretch;
        }

        .emoji-paint__palette-selection {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            cursor: default;
        }

        .emoji-paint__palette-editor-input-edit {
            width: 100%;
            /*
            NOTE: I don't know exactly why .35rem of all things, but it provides
            the same spacing between the symbols as the palette selection
            */
            letter-spacing: 0.35rem;
        }

        .emoji-paint__palette-selection-left,
        .emoji-paint__palette-selection-right {
            position: relative;
            border: 1px inset;
            border-radius: 0.25rem;
            padding: 0.175rem;
            background: var(--canvas-background);
        }

        .emoji-paint__palette-selection-left::before,
        .emoji-paint__palette-selection-right::before {
            position: absolute;
            border-radius: 100%;
            width: 2.5ch;
            color: #FFF;
            background-color: #339;
            font-size: 0.525rem;
            text-align: center;
            line-height: 2.5ch;
            aspect-ratio: 1;
        }

        .emoji-paint__palette-selection-left::before {
            content: 'L';
        }

        .emoji-paint__palette-selection-right::before {
            content: 'R';
        }

        /* endregion */

    </style>
</head>
<body>

<div id="emojiPaint"></div>

<script>

  const DEFAULT_BLANK = 'â¬œ'
  const DEFAULT_PALETTES = {
    'Squares': 'â¬›â¬œðŸŸ¥ðŸŸ¦ðŸŸ§ðŸŸ¨ðŸŸ©ðŸŸªðŸŸ«',
    'Circles': 'âš«âšªðŸ”´ðŸ”µðŸŸ ðŸŸ¡ðŸŸ¢ðŸŸ£ðŸŸ¤',
  }
  const DRAW_FUNCTIONS = {
    // DDA Line Algorithm
    lineSimple(pointA, pointB) {
      const dx = pointB.x - pointA.x
      const dy = pointB.y - pointA.y
      const steps = Math.max(Math.abs(dx), Math.abs(dy))
      const xIncrement = dx / steps
      const yIncrement = dy / steps
      let result = []
      let x = pointA.x
      let y = pointA.y

      result.push(new Point(Math.round(x), Math.round(y)))

      for (let i = 0; i < steps; i++) {
        x += xIncrement
        y += yIncrement

        result.push(new Point(Math.round(x), Math.round(y)))
      }

      return result
    },

    // Bresenham's Line Algorithm
    line(pointA, pointB) {
      let result = []
      let x0 = pointA.x
      let y0 = pointA.y
      let x1 = pointB.x
      let y1 = pointB.y
      const dx = Math.abs(x1 - x0)
      const dy = Math.abs(y1 - y0)
      const sx = (x0 < x1) ? 1 : -1
      const sy = (y0 < y1) ? 1 : -1
      let err = dx - dy

      while (true) {
        // ctx.fillRect(x0, y0, 1, 1) // Draw the current pixel
        result.push(new Point(x0, y0))

        if (x0 === x1 && y0 === y1) break

        const e2 = 2 * err
        if (e2 > -dy) {
          err -= dy
          x0 += sx
        }
        if (e2 < dx) {
          err += dx
          y0 += sy
        }
      }

      return result
    }
  }
  // @see https://stackoverflow.com/a/71619350/2379235
  const splitEmoji = (string) => [...new Intl.Segmenter().segment(string)].map(x => x.segment)

  function copyToClipboard(text) {
    const previousFocus = window.activeElement
    const textarea = document.createElement('textarea')
    textarea.className = 'copy-button-helper'
    textarea.value = text

    document.body.appendChild(textarea)

    textarea.select()
    // For mobile devices
    textarea.setSelectionRange(0, textarea.value.length)
    document.execCommand('copy')
    textarea.remove()

    previousFocus && previousFocus.focus()
  }

  class Point {
    constructor(x, y) {
      this.x = x
      this.y = y
    }

    clone() {
      return new Point(this.x, this.y)
    }
  }

  class Rectangle extends Point {
    constructor(x, y, width, height) {
      super(x, y)
      this.width = width
      this.height = height
    }

    static fromClientRect(value) {
      return new Rectangle(value.left, value.top, value.width, value.height)
    }

    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height)
    }
  }

  class Data {
    setup(width = 10, height = 10, blank = DEFAULT_BLANK, separator = '\n') {
      this.width = width
      this.height = height
      this.blank = blank
      this.separator = separator
      this.matrix = new Array(this.height)
      .fill(undefined)
      .map(() => new Array(this.width).fill(blank))
    }

    clear() {
      for (let x = 0; x < this.width; x++) {
        for (let y = 0; y < this.height; y++) {
          this.matrix[y][x] = this.blank
        }
      }
    }

    set(x, y, value) {
      if (x >= 0 && x < this.width && y >= 0 || y < this.height) {
        this.matrix[y][x] = value
      } else throw new RangeError('out of range!')
    }

    toString() {
      return this.matrix.reduce(
        (result, line) => result + line.join('') + this.separator,
        ''
      )
    }
  }

  class DataStorage {
    data = {}

    constructor() {
      this.read()
    }

    static get KEY() {
      return 'emojiPaint'
    }

    read() {
      this.data = JSON.parse(localStorage.getItem(DataStorage.KEY)) ?? {}
    }

    write() {
      localStorage.setItem(DataStorage.KEY, JSON.stringify(this.data))
    }

    getItem(key) {
      return this.data[key]
    }

    setItem(key, value) {
      this.data[key] = value
    }

    mergeItem(key, value) {
      if (value?.constructor === Object || value?.constructor === Array) {
        if (this.data[key]?.constructor === Object) {
          this.data[key] = {...this.data[key], ...value}
          return
        }

        if (this.data[key]?.constructor === Array) {
          this.data[key] = [...this.data[key], ...value]
          return
        }

        this.setItem(key, value)
      }
    }
  }

  class Metrics {
    constructor(data = DEFAULT_BLANK) {
      this.rectangle = new Rectangle(0, 0, 0, 0)
      this.element = document.createElement('div')
      this.element.classList.add('emoji-paint__metrics')
      this.element.innerText = data
    }

    measure() {
      document.body.appendChild(this.element)
      this.rectangle = new Rectangle(0, 0, this.element.offsetWidth, this.element.offsetHeight)
      document.body.removeChild(this.element)

      return this.rectangle
    }
  }

  class Toolbar {
    items = {}
    countSeparator = 0
    countSpacer = 0

    constructor(className) {
      this.element = document.createElement('div')
      this.element.classList.add('component-toolbar', className)
    }

    attachItem(identifier, element) {
      this.items[identifier] = element
      this.element.append(element)
    }

    attachSeparator() {
      const separator = document.createElement('hr')

      separator.classList.add('emoji-paint__toolbar-separator')

      this.attachItem(`separator-${this.countSeparator++}`, separator)
    }

    attachSpacer() {
      const spacer = document.createElement('div')

      spacer.classList.add('emoji-paint__toolbar-spacer')

      this.attachItem(`spacer-${this.countSpacer++}`, spacer)
    }
  }

  class ToolbarTop extends Toolbar {
    constructor(paint) {
      super('emoji-paint__toolbar-top')
      this.paint = paint
      this.setup()
    }

    setup() {
      this.setupBtnCopy()
      this.attachSpacer()
      this.setupNew()
      this.attachSeparator()
      this.setupBtnClear()
    }

    setupNew() {
      const containerNew = document.createElement('div')
      const label = document.createElement('span')
      const inputWidth = document.createElement('input')
      const inputHeight = document.createElement('input')
      const btnNew = document.createElement('button')

      containerNew.classList.add('emoji-paint__toolbar-top-new')

      label.classList.add('emoji-paint__toolbar-label')
      label.innerText = 'Size'

      inputWidth.type = inputHeight.type = 'number'
      inputWidth.value = this.paint.width
      inputHeight.value = this.paint.height

      btnNew.classList.add(
        'emoji-paint__toolbar-top-btn-new',
        'emoji-paint__icon-btn'
      )
      btnNew.title = 'New Canvas'
      btnNew.innerText = 'ðŸ’¥ï¸'
      btnNew.addEventListener('click', () => {
          this.paint.canvas.setup(
            parseInt(inputWidth.value),
            parseInt(inputHeight.value)
          )
        }
      )

      containerNew.append(label, inputWidth, inputHeight, btnNew)

      this.attachItem('new', containerNew)
    }

    setupBtnClear() {
      const btnClear = document.createElement('button')

      btnClear.classList.add(
        'emoji-paint__toolbar-top-btn-clear',
        'emoji-paint__icon-btn'
      )
      btnClear.title = 'Clear Canvas'
      btnClear.innerText = 'âŒ'
      btnClear.addEventListener('click', () => {
        this.paint.canvas.clear()
      })

      this.attachItem('btnCopy', btnClear)
    }

    setupBtnCopy() {
      const btnCopy = document.createElement('button')

      btnCopy.classList.add(
        'emoji-paint__toolbar-top-btn-copy',
        'emoji-paint__icon-btn'
      )
      btnCopy.title = 'Copy to Clipboard'
      btnCopy.innerText = 'ðŸ“‹'
      btnCopy.addEventListener('click', () => {
        copyToClipboard(this.paint.canvas.data.toString())
      })

      this.attachItem('btnCopy', btnCopy)
    }
  }

  class Palette {
    static ITEM_ID = 'emoji-paint__palette-item'
    currentPaletteName = null
    currentPalette = null
    elements = {
      container: null,
      items: null
    }

    constructor(storage = null) {
      this.onMouseDown = this.onMouseDown.bind(this)
      this.onDropdownChange = this.onDropdownChange.bind(this)
      this.onEditorChange = this.onEditorChange.bind(this)

      this.storage = storage
      this.storage.mergeItem(Palette.STORAGE_KEY, {'Custom': 'ðŸ‘¤'})

      const container = this.elements.container = document.createElement('div')
      container.classList.add('emoji-paint__palette')
      container.addEventListener('paletteDropdownChange', this.onDropdownChange)
      container.addEventListener('paletteEditorChange', this.onEditorChange)

      const items = this.elements.items = document.createElement('div')
      items.classList.add('emoji-paint__palette-items')
      items.addEventListener('mousedown', this.onMouseDown)
      items.addEventListener('contextmenu', (event) => event.preventDefault())

      this.selection = new PaletteSelection(this)
      this.dropdown = new PaletteDropdown()
      this.editor = new PaletteEditor(this)

      container.append(
        this.selection.elements.container,
        this.dropdown.element,
        this.editor.elements.container,
        items
      )

      this.dropdown.setup(this.mergedPalettes)
    }

    static get STORAGE_KEY() {
      return 'palettes'
    }

    get mergedPalettes() {
      const storedPalettes = this.storage.getItem(Palette.STORAGE_KEY)
      return {
        ...DEFAULT_PALETTES,
        ...storedPalettes
      }
    }

    setup() {
      const {items} = this.elements

      while (items.childElementCount) {
        items.removeChild(items.lastChild)
      }

      const itemsNew = this.currentPalette.map((entry, index) => {
        const item = document.createElement('input')

        item.classList.add(Palette.ITEM_ID)
        item.type = 'radio'
        item.name = Palette.ITEM_ID
        item.value = entry
        item.dataset.index = index.toString()

        return item
      })

      items.append(...itemsNew)

      this.select()
    }

    select(index = 0, button = 0) {
      const {items} = this.elements

      if (!(index in items.children)) {
        return
      }

      let item = items.children[index]

      item.checked = true

      this.selected = this.currentPalette[index]

      const detail = {index, button, selected: this.selected}
      const eventChange = new CustomEvent('paletteSelectionChange', {detail})
      this.elements.container.dispatchEvent(eventChange)
    }

    onMouseDown(event) {
      this.select(
        parseInt(event.target.dataset.index),
        event.button
      )
    }

    onDropdownChange(event) {
      const {paletteName} = event.detail

      this.currentPaletteName = paletteName
      this.currentPalette = splitEmoji(this.mergedPalettes[paletteName])
      this.setup()
    }

    onEditorChange(event) {
      this.currentPalette = event.detail.palette

      this.storage.mergeItem(
        Palette.STORAGE_KEY,
        {[this.dropdown.currentPaletteName]: this.currentPalette.join('')}
      )
      this.storage.write()
      this.setup()
    }
  }

  class PaletteDropdown {
    constructor() {
      this.onChange = this.onChange.bind(this)

      this.element = document.createElement('select')
      this.element.classList.add('emoji-paint__palette_dropdown')
      this.element.addEventListener('change', this.onChange)
    }

    setup(palettes = Object.keys(DEFAULT_PALETTES)) {
      while (this.element.childElementCount) {
        this.element.removeChild(this.element.firstChild)
      }

      const options = Object.keys(palettes).map((key) => {
        const option = document.createElement('option')

        option.text = option.value = key

        return option
      })

      this.element.append(...options)

      this.dispatchChange()
    }

    dispatchChange() {
      const option = this.element.selectedOptions.item(0)
      const detail = {paletteName: option.value}
      const event = new CustomEvent('paletteDropdownChange', {
        bubbles: true,
        cancelable: false,
        detail
      })

      this.element.dispatchEvent(event)
    }

    onChange() {
      this.dispatchChange()
    }
  }

  class PaletteSelection {
    value = {left: DEFAULT_BLANK, right: DEFAULT_BLANK}
    elements = {container: null, selectionLeft: null, selectionRight: null}

    constructor(palette) {
      this.onPaletteSelectionChange = this.onPaletteSelectionChange.bind(this)

      this.palette = palette

      const container = this.elements.container = document.createElement('div')

      container.classList.add('emoji-paint__palette-selection')

      const selectionLeft = this.elements.selectionLeft = document.createElement('div')

      selectionLeft.classList.add('emoji-paint__palette-selection-left')
      selectionLeft.textContent = DEFAULT_BLANK
      selectionLeft.title = 'Left mouse button'

      const selectionRight = this.elements.selectionRight = document.createElement('div')

      selectionRight.classList.add('emoji-paint__palette-selection-right')
      selectionRight.textContent = DEFAULT_BLANK
      selectionRight.title = 'Right mouse button'

      container.append(selectionLeft, selectionRight)

      this.palette.elements.container.addEventListener(
        'paletteSelectionChange',
        this.onPaletteSelectionChange
      )
    }

    onPaletteSelectionChange(event) {
      const {selectionLeft, selectionRight} = this.elements
      const {selected, button} = event.detail

      switch (button) {
        default:
          this.value.left = selected
          selectionLeft.textContent = selected
          break

        case 2:
          this.value.right = selected
          selectionRight.textContent = selected
          break
      }
    }
  }

  class PaletteEditor {
    elements = {container: null, btnEdit: null, inputEdit: null}

    constructor(palette) {
      this.onBtnEditClick = this.onBtnEditClick.bind(this)
      this.onInputEditBlur = this.onInputEditBlur.bind(this)
      this.onInputEditKeyPress = this.onInputEditKeyPress.bind(this)

      this.palette = palette

      const container = this.elements.container = document.createElement('div')

      container.classList.add('emoji-paint__palette-editor')

      const btnEdit = this.elements.btnEdit = document.createElement('button')

      btnEdit.classList.add(
        'emoji-paint__palette-editor-btn-edit',
        'emoji-paint__icon-btn'
      )
      btnEdit.title = 'Edit palette'
      btnEdit.textContent = 'âœï¸'
      btnEdit.addEventListener('click', this.onBtnEditClick)

      const inputEdit = this.elements.inputEdit = document.createElement('textarea')

      inputEdit.classList.add('emoji-paint__palette-editor-input-edit')
      inputEdit.addEventListener('blur', this.onInputEditBlur)
      inputEdit.addEventListener('keypress', this.onInputEditKeyPress)

      container.append(btnEdit)
    }

    enable() {
      const {items} = this.palette.elements
      const {inputEdit} = this.elements

      inputEdit.value = this.palette.currentPalette.join('')
      inputEdit.style.setProperty('height', `${items.offsetHeight}px`)

      items.replaceWith(inputEdit)

      inputEdit.focus()
    }

    disable(dispatchChange = true) {
      const {items} = this.palette.elements
      const {inputEdit} = this.elements

      inputEdit.replaceWith(items)

      const changed = (this.elements.inputEdit.value !== this.palette.dropdown.currentPalette.join(''))

      if (dispatchChange && changed) {
        this.dispatchChange()
      }
    }

    isEmoji(character) {
      return /\p{Emoji}/u.test(character)
    }

    dispatchChange() {
      const palette = [...new Set(splitEmoji(this.elements.inputEdit.value))]
      const detail = {palette}
      const event = new CustomEvent(
        'paletteEditorChange',
        {detail, bubbles: true, cancelable: false}
      )

      this.elements.container.dispatchEvent(event)
    }

    onBtnEditClick() {
      this.enable()
    }

    onInputEditKeyPress(event) {
      switch (event.code) {
        default:
          const value = String.fromCharCode(event.charCode)

          if (!this.isEmoji(value)) {
            event.preventDefault()
            alert('This not a valid emoji character!')
          }
          break

        case 'Enter':
          event.target.blur()
          break
      }
    }

    onInputEditBlur() {
      this.disable()
    }
  }

  class MouseGrid {
    setup(gridRect, cellRect) {
      this.gridRect = gridRect
      this.cellRect = cellRect
    }

    isValidCoordinate(x, y) {
      return (x >= 0 && x <= this.gridRect.width
        && y >= 0 && y <= this.gridRect.height)
    }

    getPointFromCoordinate(x, y) {
      if (!this.isValidCoordinate(x, y)) {
        return null
      }

      return new Point(
        Math.floor(x / this.cellRect.width),
        Math.floor(y / this.cellRect.height)
      )
    }

    getPointFromEvent(event) {
      return this.getPointFromCoordinate(
        event.offsetX - this.gridRect.x,
        event.offsetY - this.gridRect.y
      )
    }
  }

  class Tool {
    constructor(canvas, palette) {
      this.canvas = canvas
      this.palette = palette
      this.button = 0
      this.isMouseDown = false
      this.point = null
      this.prevPoint = null
      this.onMouseDown = this.onMouseDown.bind(this)
      this.onMouseMove = this.onMouseMove.bind(this)
      this.onMouseUp = this.onMouseUp.bind(this)
    }

    activate() {
      const e = this.canvas.element
      e.addEventListener('mousedown', this.onMouseDown)
      e.addEventListener('mousemove', this.onMouseMove)
      window.addEventListener('mouseup', this.onMouseUp)
    }

    deactivate() {
      const e = this.canvas.element
      e.removeEventListener('mousedown', this.onMouseDown)
      e.removeEventListener('mousemove', this.onMouseMove)
      window.removeEventListener('mouseup', this.onMouseUp)
    }

    apply(event) {
      const point = this.canvas.mouseGrid.getPointFromEvent(event)

      if (!point || point.x > this.canvas.width - 1 || point.y > this.canvas.height - 1) {
        return false
      }

      this.prevPoint = this.point
      this.point = point

      return !!this.point
      // Implement in child class
    }

    onMouseDown(event) {
      this.button = event.button
      this.isMouseDown = true
      this.apply(event)
    }

    onMouseMove(event) {
      if (this.isMouseDown) {
        this.apply(event)
      }
    }

    onMouseUp() {
      if (this.isMouseDown) {
        this.isMouseDown = false
        this.point = null
        this.prevPoint = null
      }
    }
  }

  class DrawTool extends Tool {
    apply(event) {
      if (super.apply(event)) {
        const points = DRAW_FUNCTIONS.line(
          this.prevPoint ?? this.point,
          this.point
        )
        const value = (this.button === 2)
          ? this.palette.selection.value.right
          : this.palette.selection.value.left

        this.canvas.draw.apply(
          this.canvas,
          [value, ...points]
        )
      }
    }
  }

  class Canvas {
    constructor() {
      this.data = new Data()
      this.metrics = new Metrics()

      this.element = document.createElement('div')
      this.element.classList.add('emoji-paint__canvas')
      this.element.addEventListener('contextmenu', (event) => event.preventDefault())
    }

    setup(width, height) {
      this.width = width
      this.height = height

      const {element, data, metrics} = this

      data.setup(this.width, this.height)
      metrics.measure()

      element.innerText = data.toString()

      this.rectangle = new Rectangle(0, 0, element.clientWidth, element.clientHeight)
      this.mouseGrid = new MouseGrid()
      this.mouseGrid.setup(this.rectangle, this.metrics.rectangle)
    }

    draw(value, ...points) {
      points.forEach((point) => this.data.set(point.x, point.y, value))
      this.element.innerText = this.data.toString()
    }

    clear() {
      if (confirm('Are you sure?')) {
        this.data.clear()
        this.element.innerText = this.data.toString()
      }
    }
  }

  class Paint {
    elements = {container: null, head: null}
    toolbars = {top: null}

    constructor(element = document.createElement('div')) {
      const {elements} = this

      const head = elements.head = document.createElement('div')
      head.classList.add('emoji-paint__head')
      head.innerText = 'ðŸŽ¨ EmojiPaint'

      const body = elements.body = document.createElement('div')
      body.classList.add('emoji-paint__body')

      const container = elements.container = element
      container.classList.add('emoji-paint__container')
      container.append(head, body)
    }

    setup(width = 10, height = 10) {
      if (!this.elements.container.parentElement) {
        document.body.append(this.elements.container)
      }

      this.width = width
      this.height = height

      this.storage = new DataStorage()
      this.canvas = new Canvas()
      this.toolbars.top = new ToolbarTop(this)

      this.elements.body.append(
        this.toolbars.top.element,
        this.canvas.element
      )

      this.canvas.setup(width, height)
      this.palette = new Palette(this.storage)
      this.tool = new DrawTool(this.canvas, this.palette)
      this.tool.activate()

      this.elements.body.append(this.palette.elements.container)
    }
  }

  const paint = new Paint(document.getElementById('emojiPaint'))
  paint.setup()

</script>

</body>
</html>
