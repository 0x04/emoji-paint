<!--
ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§
ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§
ðŸŸ§ðŸŸ§â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›ðŸŸ§ðŸŸ§
ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ¥â¬›ðŸŸ§ðŸŸ§ðŸŸ§
ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§

â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬›
â¬›â¬›ðŸŸ¥ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ¥â¬›â¬›
â¬›ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥â¬›
ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨â¬œâ¬œðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨â¬œâ¬œâ¬œâ¬œðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨â¬œâ¬œâ¬œâ¬œðŸŸ¨ðŸŸ§ðŸŸ¥
ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨â¬œâ¬œðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥
â¬›ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ§ðŸŸ¥â¬›
â¬›â¬›ðŸŸ¥ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ¥â¬›â¬›
â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬›

ðŸŸ¥ðŸŸ§ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸªðŸŸ«â¬›â¬œ
â¹ï¸âŽâœ³ï¸âœ´ï¸â‡ï¸ðŸ…¿ï¸ðŸ†™
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>EmojiPaint</title>
    <style>

        /* region Reset */
        /* @see https://www.joshwcomeau.com/css/custom-css-reset */

        *, *::before, *::after {
            box-sizing: border-box;
        }

        input, button, textarea, select {
            font: inherit;
            color: inherit;
        }

        /* endregion */

        /* region Standard HTML tags */

        body {
            margin: 0;
            padding: 1rem;
            color: #333;
            font-family: "Consolas", monospace;
        }

        /* endregion */

        /* region EmojiPaint */

        .component-metrics {
            position: absolute;
            /* TODO: same style as canvas element */
        }

        .component-paint {
            border: 1px outset;
            border-radius: 4px;
            background: #CCC;
        }

        .component-paint_head {
            padding: 0.5rem 1rem;
            border-bottom: 1px outset;
            border-radius: 3px 3px 0 0;
            background: #AAA;
        }

        .component-paint_head:first-letter {
            text-shadow: 0 0 4px #333;
        }

        .component-paint_body {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
        }

        .component-toolbar_top {
            display: flex;
        }

        .component-toolbar_top hr {
            flex: 0 1 0;
            margin-block: 0.25rem;
            margin-inline: 0.5rem;
        }

        .component-toolbar_top .component-toolbar_top-new input[type='number'] {
            width: 6ch;
            text-align: right;
        }

        .component-toolbar_label {
            margin-inline-end: 0.5rem;
        }

        .component-canvas {
            cursor: crosshair;
            user-select: none;
            background: #FFF;
            padding: 0.25rem;
            border: 1px inset;
            width: max-content;
        }

        .component-palette {
            display: flex;
            gap: 0.5rem;
        }

        .component-palette_item {
            padding: 2px;
        }

        /* endregion */

    </style>
</head>
<body>

<div id="componentPaint"></div>

<script>

  const DEFAULT_BLANK = 'â¬œ'
  const DEFAULT_PALETTES = {
    'Squares': 'â¬›â¬œðŸŸ¥ðŸŸ¦ðŸŸ§ðŸŸ¨ðŸŸ©ðŸŸªðŸŸ«',
    'Circles': 'âš«âšªðŸ”´ðŸ”µðŸŸ ðŸŸ¡ðŸŸ¢ðŸŸ£ðŸŸ¤',
  }
  const DRAW_FUNCTIONS = {
    // DDA Line Algorithm
    lineSimple(pointA, pointB) {
      const dx = pointB.x - pointA.x
      const dy = pointB.y - pointA.y
      const steps = Math.max(Math.abs(dx), Math.abs(dy))
      const xIncrement = dx / steps
      const yIncrement = dy / steps
      let result = []
      let x = pointA.x
      let y = pointA.y

      result.push(new Point(Math.round(x), Math.round(y)))

      for (let i = 0; i < steps; i++) {
        x += xIncrement
        y += yIncrement

        result.push(new Point(Math.round(x), Math.round(y)))
      }

      return result
    },

    // Bresenham's Line Algorithm
    line(pointA, pointB) {
      let result = []
      let x0 = pointA.x
      let y0 = pointA.y
      let x1 = pointB.x
      let y1 = pointB.y
      const dx = Math.abs(x1 - x0)
      const dy = Math.abs(y1 - y0)
      const sx = (x0 < x1) ? 1 : -1
      const sy = (y0 < y1) ? 1 : -1
      let err = dx - dy

      while (true) {
        // ctx.fillRect(x0, y0, 1, 1) // Draw the current pixel
        result.push(new Point(x0, y0))

        if (x0 === x1 && y0 === y1) break

        const e2 = 2 * err
        if (e2 > -dy) {
          err -= dy
          x0 += sx
        }
        if (e2 < dx) {
          err += dx
          y0 += sy
        }
      }

      return result
    }
  }

  function copyToClipboard(text) {
    const previousFocus = window.activeElement
    const textarea = document.createElement('textarea')
    textarea.className = 'copy-button-helper'
    textarea.value = text

    document.body.appendChild(textarea)

    textarea.select()
    // For mobile devices
    textarea.setSelectionRange(0, textarea.value.length)
    document.execCommand('copy')
    textarea.remove()

    previousFocus && previousFocus.focus()
  }

  class Point {
    constructor(x, y) {
      this.x = x
      this.y = y
    }

    clone() {
      return new Point(this.x, this.y)
    }
  }

  class Rectangle extends Point {
    constructor(x, y, width, height) {
      super(x, y)
      this.width = width
      this.height = height
    }

    static fromClientRect(value) {
      return new Rectangle(value.left, value.top, value.width, value.height)
    }

    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height)
    }
  }

  class Data {
    setup(width = 10, height = 10, blank = DEFAULT_BLANK, separator = '\n') {
      this.width = width
      this.height = height
      this.blank = blank
      this.separator = separator
      this.matrix = new Array(this.height)
      .fill(undefined)
      .map(() => new Array(this.width).fill(blank))
    }

    clear() {
      for (let x = 0; x < this.width; x++) {
        for (let y = 0; y < this.height; y++) {
          this.matrix[y][x] = this.blank
        }
      }
    }

    set(x, y, value) {
      if (x >= 0 && x < this.width && y >= 0 || y < this.height) {
        this.matrix[y][x] = value
      } else throw new RangeError('out of range!')
    }

    toString() {
      return this.matrix.reduce(
        (result, line) => result + line.join('') + this.separator,
        ''
      )
    }
  }

  class DataStorage {
    data = {}

    constructor() {
      this.read()
    }

    static get KEY() {
      return 'emojiPaint'
    }

    read() {
      this.data = JSON.parse(localStorage.getItem(DataStorage.KEY)) ?? {}
    }

    write() {
      localStorage.setItem(DataStorage.KEY, JSON.stringify(this.data))
    }

    getItem(key) {
      return this.data[key]
    }

    setItem(key, value) {
      this.data[key] = value
    }
  }

  class Metrics {
    constructor(data = DEFAULT_BLANK) {
      this.rectangle = new Rectangle(0, 0, 0, 0)
      this.element = document.createElement('div')
      this.element.classList.add('component-metrics')
      this.element.innerText = data
    }

    measure() {
      document.body.appendChild(this.element)
      this.rectangle = new Rectangle(0, 0, this.element.offsetWidth, this.element.offsetHeight)
      document.body.removeChild(this.element)

      return this.rectangle
    }
  }

  class Toolbar {
    items = {}

    constructor(className) {
      this.element = document.createElement('div')
      this.element.classList.add('component-toolbar', className)
    }

    attachItem(identifier, element) {
      this.items[identifier] = element
      this.element.append(element)
    }

    attachSeparator() {
      const separator = document.createElement('hr')

      this.element.append(separator)
    }
  }

  class ToolbarTop extends Toolbar {
    constructor(paint) {
      super('component-toolbar_top')
      this.paint = paint
      this.setup()
    }

    setup() {
      this.setupNew()
      this.attachSeparator()
      this.setupBtnClear()
      this.attachSeparator()
      this.setupBtnCopy()
    }

    setupNew() {
      const containerNew = document.createElement('div')
      const label = document.createElement('span')
      const inputWidth = document.createElement('input')
      const inputHeight = document.createElement('input')
      const btnNew = document.createElement('button')

      containerNew.classList.add('component-toolbar_top-new')

      label.classList.add('component-toolbar_label')
      label.innerText = 'Size'

      inputWidth.type = inputHeight.type = 'number'
      inputWidth.value = this.paint.width
      inputHeight.value = this.paint.height

      btnNew.innerText = 'New'
      btnNew.addEventListener('click', () => {
          this.paint.canvas.setup(
            parseInt(inputWidth.value),
            parseInt(inputHeight.value)
          )
        }
      )

      containerNew.append(label, inputWidth, inputHeight, btnNew)

      this.attachItem('new', containerNew)
    }

    setupBtnClear() {
      const btnClear = document.createElement('button')

      btnClear.title = 'Clear Canvas'
      btnClear.innerText = 'Clear'
      btnClear.addEventListener('click', () => {
        this.paint.canvas.clear()
      })

      this.attachItem('btnCopy', btnClear)
    }

    setupBtnCopy() {
      const btnCopy = document.createElement('button')

      btnCopy.title = 'Copy to clipboard'
      btnCopy.innerText = 'Copy'
      btnCopy.addEventListener('click', () => {
        copyToClipboard(this.paint.canvas.data.toString())
      })

      this.attachItem('btnCopy', btnCopy)
    }
  }

  class Palette {
    elements = {
      container: null,
      items: null
    }

    constructor(
      callback = () => void (0),
      storage = null,
    ) {
      this.callback = callback
      this.storage = storage
      this.onClick = this.onClick.bind(this)
      this.onDropdownChange = this.onDropdownChange.bind(this)

      this.elements.container = document.createElement('div')
      this.elements.container.classList.add('component-palette')

      this.elements.items = document.createElement('div')
      this.elements.items.classList.add('component-palette_items')
      this.elements.items.addEventListener('click', this.onClick)
      this.elements.container.append(this.elements.items)

      this.dropdown = new PaletteDropdown(this.onDropdownChange, this.storage)
      this.elements.container.prepend(this.dropdown.element)
      this.dropdown.setup()
    }

    setup() {
      const {items} = this.elements

      while (items.childElementCount) {
        items.removeChild(items.lastChild)
      }

      const itemsNew = this.palette.map((entry, index) => {
        const item = document.createElement('button')

        item.classList.add('component-palette_item')
        item.dataset.index = index.toString()
        item.innerText = entry

        return item
      })

      items.append(...itemsNew)

      this.callback(this.selected)
    }

    onClick(event) {
      this.selected = this.palette[event.target.dataset.index]
      this.callback(this.selected)
    }

    onDropdownChange(event) {
      this.palette = [...this.dropdown.selected]
      this.selected = this.palette[0]
      this.setup()
    }
  }

  class PaletteDropdown {
    constructor(
      changeHandler = () => void (0),
      storage = null
    ) {
      this.onChange = changeHandler.bind(this)
      this.storage = storage

      this.element = document.createElement('select')
      this.element.classList.add('component-palette_dropdown')
      this.element.addEventListener('change', this.onChange)
    }

    static get STORAGE_KEY() {
      return 'palettes'
    }

    get selected() {
      return [...this.element.selectedOptions.item(0).value]
    }

    setup() {
      while (this.element.childElementCount) {
        this.element.removeChild(this.element.firstChild)
      }

      const entries = this.storage.getItem(PaletteDropdown.STORAGE_KEY) ?? DEFAULT_PALETTES
      const options = Object.entries(entries).map((entry) => {
        const [key, value] = entry;
        const option = document.createElement('option')

        option.value = value.toString()
        option.innerText = key

        return option
      })

      this.element.append(...options);

      this.dispatchChange()
    }

    dispatchChange() {
      const event = new Event('change', {bubbles: true, cancelable: true})
      this.element.dispatchEvent(event)
    }
  }

  class MouseGrid {
    setup(gridRect, cellRect) {
      this.gridRect = gridRect
      this.cellRect = cellRect
    }

    isValidCoordinate(x, y) {
      return (x >= 0 && x <= this.gridRect.width
        && y >= 0 && y <= this.gridRect.height)
    }

    getPointFromCoordinate(x, y) {
      if (!this.isValidCoordinate(x, y)) {
        return null
      }

      return new Point(
        Math.floor(x / this.cellRect.width),
        Math.floor(y / this.cellRect.height)
      )
    }

    getPointFromEvent(event) {
      return this.getPointFromCoordinate(
        event.offsetX - this.gridRect.x,
        event.offsetY - this.gridRect.y
      )
    }
  }

  class Tool {
    constructor(canvas) {
      this.value = DEFAULT_BLANK
      this.canvas = canvas
      this.mouseDown = false
      this.point = null
      this.prevPoint = null
      this.onMouseDown = this.onMouseDown.bind(this)
      this.onMouseMove = this.onMouseMove.bind(this)
      this.onMouseUp = this.onMouseUp.bind(this)
    }

    activate() {
      const e = this.canvas.element
      e.addEventListener('mousedown', this.onMouseDown)
      e.addEventListener('mousemove', this.onMouseMove)
      window.addEventListener('mouseup', this.onMouseUp)
    }

    deactivate() {
      const e = this.canvas.element
      e.removeEventListener('mousedown', this.onMouseDown)
      e.removeEventListener('mousemove', this.onMouseMove)
      window.removeEventListener('mouseup', this.onMouseUp)
    }

    apply(event) {
      const point = this.canvas.mouseGrid.getPointFromEvent(event)

      if (!point || point.x > this.canvas.width - 1 || point.y > this.canvas.height - 1) {
        return false
      }

      this.prevPoint = this.point
      this.point = point

      return !!this.point
      // Implement in child class
    }

    onMouseDown(event) {
      this.mouseDown = true
      this.apply(event)
    }

    onMouseMove(event) {
      if (this.mouseDown) {
        this.apply(event)
      }
    }

    onMouseUp(event) {
      if (this.mouseDown) {
        this.apply(event)
        this.mouseDown = false
        this.point = null
        this.prevPoint = null
      }
    }
  }

  class DrawTool extends Tool {
    apply(event) {
      if (super.apply(event)) {
        const points = DRAW_FUNCTIONS.line(
          this.prevPoint ?? this.point,
          this.point
        )

        this.canvas.draw.apply(
          this.canvas,
          [this.value, ...points]
        )
      }
    }
  }

  class Canvas {
    constructor() {
      this.data = new Data()
      this.metrics = new Metrics()

      this.element = document.createElement('div')
      this.element.classList.add('component-canvas')
    }

    setup(width, height) {
      this.width = width
      this.height = height

      const {element, data, metrics} = this

      data.setup(this.width, this.height)
      metrics.measure()

      element.innerText = data.toString()

      this.rectangle = new Rectangle(0, 0, element.clientWidth, element.clientHeight)
      this.mouseGrid = new MouseGrid()
      this.mouseGrid.setup(this.rectangle, this.metrics.rectangle)
    }

    draw(value, ...points) {
      points.forEach((point) => this.data.set(point.x, point.y, value))
      this.element.innerText = this.data.toString()
    }

    clear() {
      if (confirm('Are you sure?')) {
        this.data.clear()
        this.element.innerText = this.data.toString()
      }
    }
  }

  class Paint {
    elements = {container: null, head: null}
    toolbars = {top: null}

    constructor(element = document.createElement('div')) {
      this.onPaletteChange = this.onPaletteChange.bind(this)

      const {elements} = this

      const head = elements.head = document.createElement('div')
      head.classList.add('component-paint_head')
      head.innerText = 'ðŸŽ¨ EmojiPaint'

      const body = elements.body = document.createElement('div')
      body.classList.add('component-paint_body')

      const container = elements.container = element
      container.classList.add('component-paint')
      container.append(head, body)
    }

    setup(width = 10, height = 10) {
      if (!this.elements.container.parentElement) {
        document.body.append(this.elements.container)
      }

      this.width = width
      this.height = height

      this.storage = new DataStorage()
      this.canvas = new Canvas()
      this.toolbars.top = new ToolbarTop(this)

      this.elements.body.append(
        this.toolbars.top.element,
        this.canvas.element
      )

      this.canvas.setup(width, height)
      this.tool = new DrawTool(this.canvas)
      this.tool.activate()
      this.palette = new Palette(this.onPaletteChange, this.storage)

      this.elements.body.append(this.palette.elements.container)
    }

    onPaletteChange(value) {
      this.tool.value = value
    }
  }

  console.clear()
  const paint = new Paint(document.getElementById('componentPaint'))
  paint.setup()

</script>

</body>
</html>
